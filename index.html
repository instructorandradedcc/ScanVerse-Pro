<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ScanVerse | Real CV Processing</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    height: {
                        'dvh': '100dvh', // Altura dinámica para móviles
                    }
                }
            }
        }
    </script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- OpenCV.js -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="window.cvLoaded=true"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        .lidar-grid {
            background-image: linear-gradient(rgba(0, 255, 170, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 255, 170, 0.1) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        .scanner-line {
            position: absolute; left: 0; width: 100%; height: 2px; background: #00ffaa;
            box-shadow: 0 0 10px #00ffaa; animation: scanline 3s linear infinite;
        }
        @keyframes scanline { 0% { top: 0%; opacity: 0; } 10% { opacity: 1; } 90% { opacity: 1; } 100% { top: 100%; opacity: 0; } }
        /* Fix para navegadores móviles */
        .h-safe-dvh { height: 100dvh; height: 100vh; }
        @supports (height: 100dvh) { .h-safe-dvh { height: 100dvh; } }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">

const { useState, useEffect, useRef } = React;

// --- UTILS: Computer Vision Mejorado ---

const processImageToPoints = async (imgElement, index, totalImages) => {
    return new Promise((resolve) => {
        if (!window.cv || !window.cvLoaded) {
            resolve([]); 
            return;
        }

        const src = cv.imread(imgElement);
        // Reducir tamaño interno para procesar más rápido si la imagen es gigante
        const maxDim = 800;
        let scale = 1;
        if(src.cols > maxDim || src.rows > maxDim) {
             scale = maxDim / Math.max(src.cols, src.rows);
             const dsize = new cv.Size(src.cols * scale, src.rows * scale);
             cv.resize(src, src, dsize, 0, 0, cv.INTER_AREA);
        }

        const width = src.cols;
        const height = src.rows;
        const points = [];
        
        // --- 1. Muestreo de Cuadrícula (Para rellenar paredes vacías) ---
        // Esto soluciona que el modelo se vea vacío. Escaneamos "todo" cada X pixeles.
        const gridStep = 12; // Muestra un punto cada 12 pixeles (ajustar para densidad vs rendimiento)
        
        // Calcular geometría base
        const anglePerImage = (Math.PI * 2) / totalImages;
        const baseAngle = index * anglePerImage;
        const radius = 4.5; // Radio un poco más amplio

        // Función auxiliar para agregar punto
        const addPoint = (x, y, r, g, b) => {
             // Mapeo Cilíndrico
             const u = x / width; 
             // Ajuste de FOV: Asumimos que la cámara ve unos 60 grados (PI/3)
             // El "- u" invierte el barrido para coincidir con la rotación
             const theta = baseAngle - (u * (Math.PI / 2.5)) + Math.PI; 

             const v = (y / height) - 0.5;
             const h = -v * 4; // Altura escalada

             const pX = radius * Math.sin(theta);
             const pZ = radius * Math.cos(theta);
             const pY = h;

             // Añadimos un poco de "ruido" de profundidad aleatorio para que no parezca un papel plano perfecto
             // Esto le da volumen a las superficies irregulares
             const depthNoise = (Math.random() - 0.5) * 0.1; 

             points.push({
                pos: [pX * (1 + depthNoise), pY, pZ * (1 + depthNoise)],
                color: [r/255, g/255, b/255]
             });
        };

        // Bucle Denso (Relleno)
        for (let y = 0; y < height; y += gridStep) {
            for (let x = 0; x < width; x += gridStep) {
                const pixel = src.ucharPtr(y, x);
                addPoint(x, y, pixel[0], pixel[1], pixel[2]);
            }
        }

        // --- 2. Detección de Detalles (ORB) ---
        // Añadimos puntos extra donde haya bordes reales para definir mejor los objetos
        const gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        const orb = new cv.ORB(1500); // Aumentado de 500 a 1500
        const keypoints = new cv.KeyPointVector();
        const descriptors = new cv.Mat();
        orb.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);

        for (let i = 0; i < keypoints.size(); i++) {
            const kp = keypoints.get(i);
            const x = Math.floor(kp.pt.x);
            const y = Math.floor(kp.pt.y);
            if(x < width && y < height) {
                const pixel = src.ucharPtr(y, x);
                addPoint(x, y, pixel[0], pixel[1], pixel[2]);
            }
        }

        // Limpieza
        src.delete(); gray.delete(); orb.delete(); keypoints.delete(); descriptors.delete();
        resolve(points);
    });
};

const Icon = ({ name, size = 24, className }) => {
    useEffect(() => lucide.createIcons(), [name]);
    return <i data-lucide={name} width={size} height={size} className={className}></i>;
};

// Pantalla 1: Inicio
const HomeScreen = ({ onStart }) => (
    <div className="h-safe-dvh w-full flex flex-col items-center justify-center bg-slate-900 text-white p-6 relative overflow-hidden">
        <div className="absolute inset-0 lidar-grid opacity-20 pointer-events-none"></div>
        <div className="z-10 text-center max-w-md">
            <div className="w-24 h-24 bg-emerald-500/10 rounded-full flex items-center justify-center ring-1 ring-emerald-500/50 mx-auto mb-6">
                <Icon name="scan-face" size={48} className="text-emerald-400" />
            </div>
            <h1 className="text-4xl font-bold mb-2 bg-clip-text text-transparent bg-gradient-to-r from-emerald-400 to-blue-500">ScanVerse Pro</h1>
            <p className="text-slate-400 mb-8 text-sm">Escaneo Denso Híbrido.<br/>Captura paredes y detalles completos.</p>
            <button onClick={onStart} className="w-full py-4 bg-emerald-600 hover:bg-emerald-500 rounded-xl font-bold shadow-lg shadow-emerald-900/50 transition flex items-center justify-center gap-2">
                <Icon name="camera" size={20} /> INICIAR ESCANEO
            </button>
        </div>
    </div>
);

// Pantalla 2: Cámara (UI Corregida)
const CaptureScreen = ({ onProcess, onBack }) => {
    const videoRef = useRef(null);
    const canvasRef = useRef(null);
    const [photos, setPhotos] = useState([]);
    const [stream, setStream] = useState(null);

    useEffect(() => {
        // Pedir camara con resolución ideal
        navigator.mediaDevices.getUserMedia({ 
            video: { 
                facingMode: 'environment',
                width: { ideal: 1280 }, // Mejor calidad
                height: { ideal: 720 }
            } 
        })
        .then(s => {
            setStream(s);
            if(videoRef.current) videoRef.current.srcObject = s;
        })
        .catch(e => console.error("Sin cámara", e));
        return () => { if(stream) stream.getTracks().forEach(t => t.stop()); }
    }, []);

    const takePhoto = () => {
        if(!videoRef.current || !canvasRef.current) return;
        const vid = videoRef.current;
        const canvas = canvasRef.current;
        // Capturar a resolución media para no explotar la memoria
        canvas.width = vid.videoWidth / 2; 
        canvas.height = vid.videoHeight / 2;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(vid, 0, 0, canvas.width, canvas.height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
        setPhotos(prev => [...prev, dataUrl]);
    };

    return (
        // Usamos h-safe-dvh para asegurar altura correcta en movil
        <div className="h-safe-dvh bg-black flex flex-col relative overflow-hidden">
            
            {/* Visor de Video (Ocupa todo el espacio disponible menos controles) */}
            <div className="flex-1 relative overflow-hidden bg-black">
                <video ref={videoRef} autoPlay playsInline muted className="w-full h-full object-cover opacity-90" />
                
                {/* Guía Visual */}
                <div className="absolute inset-0 pointer-events-none flex items-center justify-center">
                     <div className="w-[70%] aspect-square border-2 border-white/30 rounded-lg relative">
                        <div className="absolute top-0 left-0 w-6 h-6 border-t-4 border-l-4 border-emerald-400 -mt-1 -ml-1"></div>
                        <div className="absolute top-0 right-0 w-6 h-6 border-t-4 border-r-4 border-emerald-400 -mt-1 -mr-1"></div>
                        <div className="absolute bottom-0 left-0 w-6 h-6 border-b-4 border-l-4 border-emerald-400 -mb-1 -ml-1"></div>
                        <div className="absolute bottom-0 right-0 w-6 h-6 border-b-4 border-r-4 border-emerald-400 -mb-1 -mr-1"></div>
                        <div className="scanner-line opacity-50"></div>
                    </div>
                </div>
            </div>

            {/* Controles UI - Con padding extra bottom (pb-8/pb-12) para evitar la barra del sistema */}
            <div className="bg-slate-900/95 backdrop-blur-md pt-4 pb-12 px-6 rounded-t-3xl border-t border-slate-700 shadow-2xl z-20 shrink-0">
                
                {/* Thumbnails */}
                <div className="flex gap-2 overflow-x-auto mb-6 pb-2 min-h-[60px]">
                    {photos.length === 0 && <span className="text-slate-500 text-xs w-full text-center mt-2">Las fotos aparecerán aquí</span>}
                    {photos.map((p, i) => (
                        <div key={i} className="relative shrink-0">
                            <img src={p} className="w-12 h-16 object-cover rounded-lg border border-slate-500" />
                            <div className="absolute -top-1 -right-1 bg-emerald-500 w-4 h-4 rounded-full border border-black flex items-center justify-center text-[8px] text-black font-bold">{i+1}</div>
                        </div>
                    ))}
                </div>

                {/* Botonera Principal - Elevada */}
                <div className="flex items-center justify-between max-w-sm mx-auto">
                    <button onClick={onBack} className="p-4 bg-slate-800 rounded-full text-white hover:bg-slate-700 transition">
                        <Icon name="x" size={24} />
                    </button>
                    
                    <button onClick={takePhoto} className="group relative">
                        <div className="w-20 h-20 rounded-full border-4 border-white/30 flex items-center justify-center">
                            <div className="w-16 h-16 bg-white rounded-full group-active:scale-90 transition-transform shadow-[0_0_20px_rgba(255,255,255,0.5)]"></div>
                        </div>
                    </button>

                    <button 
                        onClick={() => photos.length > 0 && onProcess(photos)} 
                        disabled={photos.length === 0}
                        className={`p-4 rounded-full text-white transition-all shadow-lg ${photos.length>0 ? 'bg-emerald-500 hover:bg-emerald-400 shadow-emerald-500/30' : 'bg-slate-800 opacity-30'}`}
                    >
                        <Icon name="arrow-right" size={24} />
                    </button>
                </div>
                
                <p className="text-center text-slate-500 text-xs mt-4">Toma fotos girando 360° para cerrar el círculo</p>
            </div>
            
            <canvas ref={canvasRef} className="hidden" />
        </div>
    );
};

// Pantalla 3: Procesamiento
const ProcessingScreen = ({ photos, onComplete }) => {
    const [status, setStatus] = useState("Iniciando Motor...");
    const [progress, setProgress] = useState(0);
    const [currentImg, setCurrentImg] = useState(null);
    const [totalPoints, setTotalPoints] = useState(0);
    const imgRef = useRef(null);

    useEffect(() => {
        const processAll = async () => {
            let checks = 0;
            while(!window.cvLoaded && checks < 20) {
                await new Promise(r => setTimeout(r, 500));
                checks++;
            }
            
            let allPoints = [];
            for (let i = 0; i < photos.length; i++) {
                setStatus(`Escaneando Superficies (${i + 1}/${photos.length})`);
                setCurrentImg(photos[i]);
                setProgress(((i) / photos.length) * 100);
                await new Promise(r => setTimeout(r, 50)); 
                
                if(imgRef.current) {
                    const points = await processImageToPoints(imgRef.current, i, photos.length);
                    setTotalPoints(prev => prev + points.length);
                    allPoints = [...allPoints, ...points];
                }
            }
            setStatus("Finalizando Modelo Denso...");
            setProgress(100);
            setTimeout(() => onComplete(allPoints), 800);
        };
        processAll();
    }, [photos]);

    return (
        <div className="h-safe-dvh bg-slate-900 text-white flex flex-col items-center justify-center p-6">
            <div className="relative w-full max-w-sm aspect-video mb-8 bg-black rounded-xl overflow-hidden border border-slate-700 shadow-2xl ring-1 ring-emerald-500/30">
                {currentImg && <img ref={imgRef} src={currentImg} className="w-full h-full object-contain opacity-60" crossOrigin="anonymous" />}
                <div className="absolute inset-0 flex items-center justify-center">
                    <div className="scanner-line"></div>
                </div>
            </div>
            <h2 className="text-xl font-bold font-mono text-emerald-400 mb-2">{status}</h2>
            <div className="w-64 h-2 bg-slate-800 rounded-full overflow-hidden mb-4">
                <div className="h-full bg-emerald-500 transition-all duration-300" style={{width: `${progress}%`}}></div>
            </div>
            <div className="text-slate-400 font-mono text-sm border border-slate-700 px-4 py-2 rounded bg-slate-800/50">
                Puntos Capturados: <span className="text-white">{totalPoints.toLocaleString()}</span>
            </div>
        </div>
    );
};

// Pantalla 4: Visor Denso
const Viewer3D = ({ pointCloudData, onReset }) => {
    const mountRef = useRef(null);

    useEffect(() => {
        if (!mountRef.current) return;
        const width = mountRef.current.clientWidth;
        const height = mountRef.current.clientHeight;
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020617); // Slate 950 muy oscuro

        const camera = new THREE.PerspectiveCamera(70, width / height, 0.01, 100);
        camera.position.set(0, 0, 0.1); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(width, height);
        mountRef.current.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.rotateSpeed = -0.6;
        controls.zoomSpeed = 1.2;

        if(pointCloudData && pointCloudData.length > 0) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            pointCloudData.forEach(pt => {
                positions.push(...pt.pos);
                colors.push(...pt.color);
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // Puntos un poco más grandes y densos para que parezca sólido
            const material = new THREE.PointsMaterial({ 
                size: 0.05, 
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.85
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        const animate = () => {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        };
        animate();

        return () => { if(mountRef.current) mountRef.current.innerHTML = ''; };
    }, [pointCloudData]);

    return (
        <div className="h-safe-dvh relative bg-black">
            <div ref={mountRef} className="w-full h-full cursor-move" />
            
            <div className="absolute top-4 left-4 right-4 flex justify-between items-start pointer-events-none">
                <div className="bg-black/60 backdrop-blur px-4 py-2 rounded-lg border border-white/10">
                    <h1 className="font-bold text-white text-sm">Modelo Generado</h1>
                    <p className="text-[10px] text-emerald-400">Alta Densidad ({pointCloudData.length} pts)</p>
                </div>
            </div>
            
            <div className="absolute bottom-10 w-full flex justify-center pointer-events-none">
                <button onClick={onReset} className="bg-emerald-600 hover:bg-emerald-500 text-white px-6 py-3 rounded-full shadow-lg pointer-events-auto transition font-bold text-sm flex items-center gap-2">
                    <Icon name="refresh-cw" size={16} /> NUEVO ESCANEO
                </button>
            </div>
        </div>
    );
};

const App = () => {
    const [step, setStep] = useState('home');
    const [capturedPhotos, setCapturedPhotos] = useState([]);
    const [points, setPoints] = useState([]);

    return (
        <>
            {step === 'home' && <HomeScreen onStart={() => setStep('capture')} />}
            {step === 'capture' && <CaptureScreen onBack={() => setStep('home')} onProcess={(p) => { setCapturedPhotos(p); setStep('process'); }} />}
            {step === 'process' && <ProcessingScreen photos={capturedPhotos} onComplete={(d) => { setPoints(d); setStep('view'); }} />}
            {step === 'view' && <Viewer3D pointCloudData={points} onReset={() => setStep('home')} />}
        </>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

</script>
</body>
</html>
